@startuml
skinparam groupInheritance 2
skinparam backgroundColor #CCCCCC

class Game {
  -WorldMap world
  -Inventory inventory

  +WorldMap getWorld()
  +Inventory getInventory()
}

class Inventory {
  -Map<ResourceType, Integer> resources
  {static} -Inventory instance

  +void add(final ResourceType type, final int amount)
  +void remove(final ResourceType type, final int amount)
  +int get(final ResourceType type)
  {static} +Inventory getInstance()
}

class WorldMap {
  -int width
  -int height
  -List<List<Cell>> cells
  {static} -WorldMap instance


  +int getWidth()
  +int getHeight()
  +List<List<Cell>> getCells()

  +Cell getCell(final int x, final int y)
  +void insertUnits(List<Unit> units)

  +WorldMap getInstance(int width, int height)
  +WorldMap getInstance()
}

class Cell {
  -int x
  -int y
  -int ressourceAmount
  -ResourceType type
  -Unit unit

  +int getX()
  +int getY()
  +int getResourceCount()
  +void setResourceCount(final int count)
  +ResourceType getResourceType()
  +Unit getUnit()
  +void setUnit(final Unit unit)

  +void insertUnit(final Unit unit)
  +int mine(final int amount)

  +Cell findClosest(ResourceType resourceType)
}

enum ResourceType {
  {field} +WOOD (spawnChance=0.3, maxVeinSize=50)
  {field} +STONE (spawnChance=0.3, maxVeinSize=50)
  {field} +GOLD (spawnChance=0.3, maxVeinSize=50)
  {field} +FOOD (spawnChance=0.3, maxVeinSize=50)

  -float spawnChance
  -int maxVeinSize

  +float getSpawnChance()
  +int getMaxVeinSize()

  {static} +ResourceType getRandomType()
}

abstract class Producible {
  {abstract} -Map<ResourceType, Integer> cost

  {abstract} +Map<ResourceType, Integer> getCost()
}

abstract class Unit extends Producible {
  -int x
  -int y
  -int speed
  -int hunger
  -int xp
  -boolean canMine
  -Tool tool

  +int getX()
  +void setX(final int x)
  +int getY()
  +void setY(final int y)
  +int getSpeed()
  +int getHunger()
  +Tool getTool()
  +void setTool(final Tool tool)
  +boolean canMine()
  +void setCanMine(final boolean canMine)
  +void mine()
  +void move(final int x, final int y)
  +void eat()
}

class Group extends Unit {
  -List<Unit> units

  +List<Unit> getUnits()

  +void mine()
  +boolean canMove(final int x, final int y)
  +void move(final int x, final int y)
  +boolean canEat(final Inventory inventory)
}

class UnitModifier {
  #Unit unit
  #boolean isActive

  +boolean isEfficiencyMultiplier()
  +int updateEfficiency(int efficiency)

  +boolean isSpeedMultiplier()
  +int updateSpeed(int speed)

  +boolean isHungerMultiplier()
  +int updateHunger(int hunger)

  +void update()
}

class ExpertModifier extends UnitModifier {
  -int deactivateCountdown
}

class RiderModifier extends UnitModifier {
}

class Tool extends Producible {
  -int efficiency
  -ResourceType type

  +int getEfficiency()
  +ResourceType getResourceType()
}

abstract class Building<T extends Producible> {
  {abstract} +T produce()
}

class BuildingFactory {
  +Building<Unit> createUnitBuilding()
  +Building<Tool> createToolBuilding(ResourceType type)
}

@enduml